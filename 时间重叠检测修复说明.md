# 时间重叠检测修复说明

## 🐛 问题描述

```
pymysql.err.IntegrityError: (1062, "Duplicate entry '1-X2221-2-3' for key 'schedules.uk_version_time_space'")
```

多个课程在时间重叠的情况下被分配到同一教室。

## 📊 问题案例

### 错误的逻辑（修复前）

```python
# 使用时间段元组作为键
time_range = (weekday, start_slot, end_slot)
allocated_classrooms[time_range] = set(classroom_ids)

# 问题：
课程A: 周二 3-5节 → time_range = (2, 3, 5)
课程B: 周二 3-4节 → time_range = (2, 3, 4)  # 不同的键！

# 结果：两个课程都可以选择X2221，导致冲突
```

**示例冲突**：

```
[9] 线性代数B: 周二 第3-5节
    X1310 (容量100) → X2221 (容量60) ✓ [分配成功]

[13] 计算机程序设计: 周二 第3-4节
    X4152 (容量100) → X2221 (容量60) ✗ [冲突！3-4节与3-5节重叠]
```

## ✅ 修复方案

### 正确的逻辑（修复后）

```python
# 使用单个时间槽作为键
allocated_classrooms[(weekday, slot)] = set(classroom_ids)

# 分配时，检查所有时间槽
for slot in range(start_slot, end_slot + 1):
    occupied.update(allocated_classrooms[(weekday, slot)])

# 标记时，标记所有时间槽
for slot in range(start_slot, end_slot + 1):
    allocated_classrooms[(weekday, slot)].add(classroom_id)
```

**优化后的流程**：

```
课程A: 周二 3-5节
  检查: (2,3), (2,4), (2,5) 的占用情况
  分配: X2221
  标记: (2,3)→X2221, (2,4)→X2221, (2,5)→X2221

课程B: 周二 3-4节
  检查: (2,3), (2,4) 的占用情况
  发现: (2,3)已被X2221占用 ✗
  结果: X2221被排除，选择其他教室 ✓
```

## 🎯 测试案例

### 案例 1：完全重叠

```
课程A: 周二 3-5节 (3节课)
课程B: 周二 3-5节 (3节课)
结果: 不能使用同一教室 ✓
```

### 案例 2：部分重叠

```
课程A: 周二 3-5节 (3节课)
课程B: 周二 4-6节 (3节课)
课程C: 周二 3-4节 (2节课)
结果: 三者都不能使用同一教室 ✓
```

### 案例 3：不重叠

```
课程A: 周二 3-5节 (3节课)
课程B: 周二 6-8节 (3节课)
结果: 可以使用同一教室 ✓
```

### 案例 4：相邻但不重叠

```
课程A: 周二 3-5节 (3节课，到第5节结束)
课程B: 周二 6-8节 (3节课，从第6节开始)
结果: 可以使用同一教室 ✓
```

## 📝 代码对比

### 修复前

```python
# 粗粒度检测（错误）
time_range = (weekday, start_slot, end_slot)
occupied.update(allocated_classrooms[time_range])

# 分配
allocated_classrooms[time_range].add(classroom_id)
```

### 修复后

```python
# 细粒度检测（正确）
for slot in range(start_slot, end_slot + 1):
    occupied.update(allocated_classrooms[(weekday, slot)])

# 分配
for slot in range(start_slot, end_slot + 1):
    allocated_classrooms[(weekday, slot)].add(classroom_id)
```

## 🔍 验证逻辑

### 数据结构

```python
allocated_classrooms = {
    (2, 3): {X2221, X2222},  # 周二第3节
    (2, 4): {X2221, X2223},  # 周二第4节
    (2, 5): {X2221},         # 周二第5节
    (2, 6): {X2222},         # 周二第6节
}
```

### 查询示例

```python
# 课程: 周二 3-5节
occupied = set()
for slot in [3, 4, 5]:
    occupied.update(allocated_classrooms[(2, slot)])
# 结果: {X2221, X2222, X2223}
# 这三个教室都不能用
```

## ✨ 优化效果

### 修复前

```
13个优化方案，应用时崩溃：
IntegrityError: Duplicate entry '1-X2221-2-3'
```

### 修复后

```
13个优化方案，全部成功应用：
- 每个教室在每个时间槽最多被分配一次
- 时间重叠的课程自动选择不同教室
- 无数据库约束冲突
```

## 🎉 总结

通过将时间段检测从**粗粒度**（时间段元组）改为**细粒度**（单个时间槽），成功解决了时间重叠导致的教室重复分配问题。

**核心改进**：

- ✅ 精确检测时间重叠
- ✅ 避免重复分配
- ✅ 自动选择替代教室
- ✅ 确保数据库完整性
