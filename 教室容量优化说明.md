# 教室容量优化说明

## 📋 优化目标

确保教室容量分配合理：

1. ✅ **容量必须充足**：教室容量 ≥ 上课人数
2. ✅ **避免过度浪费**：教室容量不应远大于上课人数
3. ✅ **提高利用率**：目标利用率 80%-95%

## 🔧 已实施的优化

### 1. 容量硬性检查（已有）

```python
# 硬约束：教室容量必须 >= 学生人数
if classroom.capacity < task.student_count:
    penalty += -60000  # 极高惩罚
```

### 2. 容量浪费过滤（新增）

```python
# 筛选时就排除容量浪费过大的教室
max_waste_ratio = {
    小班(<30人): 50%,   # 允许最多浪费50%
    中班(30-60): 40%,   # 允许最多浪费40%
    大班(>60人): 30%    # 允许最多浪费30%
}

if (capacity - students) / capacity > max_waste_ratio:
    continue  # 跳过容量过大的教室
```

**效果**：

- 30 人的班级，不会分配到 100 人教室（浪费 70% > 50%）
- 30 人的班级，可以分配到 50 人教室（浪费 40% ≤ 50%）

### 3. 利用率评分优化（更新）

**旧逻辑**：

- 最佳区间：75%-90%
- 次优区间：60%-75%

**新逻辑**（更严格）：

- 🟢 **最佳区间**：80%-95% 利用率
- 🟡 **次优区间**：70%-80% 利用率
- 🟢 **可接受**：95%-100%（接近满员）
- 🟠 **勉强可接受**：60%-70%（有一定浪费）
- 🔴 **大幅惩罚**：<60% 或 >100%

**评分函数**：

```python
def utilization_score(classroom):
    utilization = students / capacity

    if 0.80 <= utilization <= 0.95:
        return abs(0.875 - utilization)  # 最接近87.5%最好
    elif 0.70 <= utilization < 0.80:
        return 0.10 + abs(0.75 - utilization)
    elif 0.95 < utilization <= 1.0:
        return 0.08 + abs(0.975 - utilization)
    elif 0.60 <= utilization < 0.70:
        return 0.20 + abs(0.65 - utilization)  # 更高惩罚
    else:
        return 1.0 + abs(0.85 - utilization)  # 大幅惩罚
```

## 📊 验证工具

### 使用方法

```bash
# 检查版本1的教室利用率
python check_classroom_utilization.py 1
```

### 输出内容

- 总排课数
- 总浪费座位数
- 利用率分布统计
- 容量不足的课程（严重问题）
- 容量浪费最严重的课程
- 优秀案例展示
- 平均利用率
- 优化建议

## 📈 预期效果

### 优化前

```
利用率分布:
  容量不足: 0%
  优秀(≥95%): 15%
  良好(80-95%): 30%
  一般(60-80%): 40%
  浪费(<60%): 15%  ← 需要改进
平均利用率: 72%
```

### 优化后（预期）

```
利用率分布:
  容量不足: 0%
  优秀(≥95%): 20%
  良好(80-95%): 50%  ← 大幅提升
  一般(60-80%): 25%
  浪费(<60%): 5%   ← 显著降低
平均利用率: 85%    ← 提升13%
```

## 🎯 优化策略

### 分班规模适配

| 班级规模     | 最大浪费率 | 示例                  |
| ------------ | ---------- | --------------------- |
| 小班(<30 人) | 50%        | 25 人 → 30-50 人教室  |
| 中班(30-60)  | 40%        | 45 人 → 45-75 人教室  |
| 大班(>60 人) | 30%        | 80 人 → 80-115 人教室 |

### 理想匹配示例

- 25 人班级 → 30 人教室（利用率 83%）✅
- 45 人班级 → 50 人教室（利用率 90%）✅
- 80 人班级 → 90 人教室（利用率 89%）✅

### 避免的情况

- ❌ 25 人班级 → 60 人教室（利用率 42%，浪费 58% > 50%）
- ❌ 45 人班级 → 100 人教室（利用率 45%，浪费 55% > 40%）
- ❌ 80 人班级 → 150 人教室（利用率 53%，浪费 47% > 30%）

## 🚀 使用建议

### 1. 重新排课

使用优化后的算法重新生成排课：

```bash
python suan2.py --version 2 --population 250 --generations 500
```

### 2. 验证结果

```bash
python check_classroom_utilization.py 2
```

### 3. 对比分析

对比新旧版本的利用率：

```bash
python check_classroom_utilization.py 1  # 旧版本
python check_classroom_utilization.py 2  # 新版本
```

## 📝 技术细节

### 修改的文件

- `genetic_algorithm.py` - `_select_classroom()` 方法

### 关键改进

1. ✅ 添加容量浪费率过滤
2. ✅ 更严格的利用率评分
3. ✅ 基于班级规模的差异化策略

### 向后兼容

- ✅ 保持原有硬约束检查
- ✅ 不影响其他功能
- ✅ 可以随时回退

## ⚠️ 注意事项

1. **教室资源充足性**：

   - 如果小教室数量不足，可能导致排课失败
   - 建议先运行验证工具检查教室配置

2. **特殊需求处理**：

   - 需要特殊设施的课程优先满足设施需求
   - 容量匹配在满足设施后进行

3. **连续性优先**：
   - 同教师/班级的课程优先使用相同教室
   - 连续性权重略高于容量匹配
