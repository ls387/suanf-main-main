# 个性化约束分析与优化工具使用说明

## 概述

排课系统提供了两个强大的工具来分析和优化未满足的个性化约束：

1. **`show_unsatisfied_constraints.py`** - 显示所有未满足的约束
2. **`analyze_conflicts.py`** - 分析冲突并提供优化功能

---

## 1. show_unsatisfied_constraints.py - 约束分析工具

### 功能说明

该工具会分析排课结果，检测 **7 个维度** 的软约束满足情况：

#### 1.1 教师个性化偏好分析

- **检测内容**: 教师偏好时间（PREFERRED）和避免时间（AVOIDED）是否满足
- **输出信息**:
  - ✅ 已满足的偏好/避免时间数量
  - ⚠️ 未满足的偏好时间详情（教师、时间段、惩罚分数）
  - ⚠️ 违反的避免时间详情（教师、时间段、课程、惩罚分数）
  - 💡 标注是否可通过调整优化

**示例输出**:

```
【1. 教师个性化偏好分析】
----------------------------------------------------------------------
✅ 所有教师避免时段均已满足
```

#### 1.2 教室容量利用率分析

- **检测内容**: 教室利用率过低（<50%）或过高（≥90%）
- **输出信息**:
  - 低利用率教室列表（课程、教室、容量、学生数、浪费座位）
  - 高利用率教室列表（可能拥挤的教室）
  - 💡 建议更换为容量更合适的教室

**示例输出**:

```
⚠️  教室利用率低(<50%): 28 处
  (建议更换为容量更小的教室)
  1. 英语I - X2316
     周三 3-5节
     容量:150 学生:25 利用率:16.7% 浪费:125座
```

#### 1.3 学生每日课时负荷分析

- **检测内容**: 班级每天上课节数是否过多（≥8 节）
- **输出信息**:
  - 负荷过重的班级列表
  - 星期、总节数、课程数量
  - 课程列表
  - 💡 建议调整课程分布

**示例输出**:

```
⚠️  学生每日课时过多(≥8节): 72 处
  1. 城市设计2025-02班 - 周三
     共14节，5门课程
     课程: 计算机程序设计, 思想道德与法治, 工程创新实训
```

#### 1.4 **任务关系约束分析** ⭐ 新增

- **检测内容**: 同一门课程多次上课的时间关系约束
- **约束类型**:
  - `REQUIRE_SAME_DAY`: 要求两次课在同一天
  - `AVOID_CONSECUTIVE_DAYS`: 避免连续两天上课
  - `MIN_DAYS_APART`: 要求至少间隔 N 天
- **输出信息**:
  - 违反的约束类型
  - 问题描述
  - 两次课的实际时间
  - 惩罚分数
  - 💡 **可通过调整时间优化**

**示例输出**:

```
⚠️  任务关系约束未满足: 6 处
  1. 高等数学I - REQUIRE_SAME_DAY
     要求同一天，实际: 周一 和 周三
     第1次: 周一 第3节, 第2次: 周三 第3节
     惩罚分数: 200
     💡 可通过调整时间优化
```

#### 1.5 课程时段偏好分析

- **检测内容**: 必修/通识课是否安排在晚上（11-13 节）或周末
- **输出信息**:
  - 晚上上课的必修课列表
  - 周末上课的必修课列表
  - 💡 建议调整到白天/工作日

#### 1.6 教室连续性分析

- **检测内容**: 同一门课程是否使用多个教室
- **输出信息**:
  - 使用多个教室的课程列表
  - 每个教室使用次数
  - 💡 建议固定在一个教室

#### 1.7 教师跨校区通勤分析

- **检测内容**: 同一教师在同一时段是否需要跨校区上课
- **输出信息**:
  - 跨校区通勤的教师和时间
  - 校区信息
  - 💡 建议调整时间避免通勤冲突

### 使用方法

```bash
# 分析指定版本的排课结果
python show_unsatisfied_constraints.py <version_id>

# 示例
python show_unsatisfied_constraints.py 1
```

### 输出文件

运行后会生成:

- **Excel 详细报告**: `未满足约束详细报告_版本{version_id}_{timestamp}.xlsx`
  - 包含所有 7 个维度的详细违反信息
  - 便于导出、排序、筛选

### 优化建议

工具会在最后提供优化建议总结:

```
【优化建议总结】
======================================================================

发现 130 处可优化点，建议：

1. 调整遗传算法参数：
   - 增加种群大小 (--population 300)
   - 增加迭代代数 (--generations 200)
   - 调整惩罚分数权重

2. 调整约束配置：
   - 降低部分软约束的惩罚分数
   - 放宽教师偏好时间范围
   - 增加可用教室数量

3. 手动微调：
   - 使用 analyze_conflicts.py 优化容量冲突
   - 针对特定课程手动调整时间/教室
```

---

## 2. analyze_conflicts.py - 冲突优化工具

### 功能说明

该工具不仅可以分析冲突，还提供 **三阶段优化** 功能：

#### 阶段 1: 解决容量不足冲突（硬约束）

- 自动为容量不足的课程寻找更大的教室
- 避免重复分配教室

#### 阶段 2: 解决时间冲突（硬约束）

- 自动为有冲突的课程寻找无冲突时间槽
- 处理教师/班级/教室时间冲突

#### 阶段 3: 优化软约束

包括三个子功能：

##### 3.1 优化教室容量利用率

- 为利用率过低的课程更换更小的教室
- 为利用率过高的课程更换更大的教室
- **可优化**: ✅

##### 3.2 优化教师个性化偏好

- 尝试满足教师偏好时间（PREFERRED）
- 尝试避免教师避免时间（AVOIDED）
- 在不违反硬约束的前提下调整
- **可优化**: ✅

##### 3.3 **优化任务关系约束** ⭐ 新增

- 尝试满足 `REQUIRE_SAME_DAY` 约束
- 尝试满足 `AVOID_CONSECUTIVE_DAYS` 约束
- 尝试满足 `MIN_DAYS_APART` 约束
- 在不违反硬约束的前提下调整任务时间
- **可优化**: ✅

### 使用方法

```bash
# 分析冲突并优化
python analyze_conflicts.py <version_id>

# 示例
python analyze_conflicts.py 1
```

### 交互式优化流程

工具会逐步引导您完成优化:

```
1. 首先显示所有冲突统计
2. 第一阶段: 优化容量不足冲突
   - 显示可用的教室替换方案
   - 询问: 是否应用这些调整? (y/n)

3. 第二阶段: 优化时间冲突
   - 显示可用的时间调整方案
   - 询问: 是否应用这些调整? (y/n)

4. 第三阶段: 优化软约束
   4.1 优化教室利用率
       - 显示教室替换方案
       - 询问: 是否应用这些利用率优化? (y/n)

   4.2 优化教师偏好
       - 显示时间调整方案
       - 询问: 是否应用这些调整? (y/n)

   4.3 优化任务关系约束 ⭐ 新增
       - 显示任务时间调整方案
       - 询问: 是否应用这些调整? (y/n)
```

### 优化示例

#### 任务关系约束优化示例

```
优化任务关系约束（课程多次上课的时间关系）
--------------------------------------------------------------------------------

找到 6 处任务关系约束违反

优化: 高等数学I - REQUIRE_SAME_DAY
  当前: 任务A=周一 第3节, 任务B=周三 第3节
  目标: 将任务B调整到 周一
  ✓ 找到可用时间: 周一 第6-8节

优化: 高等数学I - AVOID_CONSECUTIVE_DAYS
  当前: 任务A=周二 第9节, 任务B=周一 第11节
  目标: 将任务B调整到非连续天 周三
  ✓ 找到可用时间: 周三 第9-11节

找到 6 个可优化的任务关系约束

调整详情:
  [1] 高等数学I
      满足任务关系约束: REQUIRE_SAME_DAY
      周三 第3节 → 周一 第6节
  [2] 高等数学I
      满足任务关系约束: AVOID_CONSECUTIVE_DAYS
      周一 第11节 → 周三 第9节
  ...

是否应用这些调整? (y/n): y

✅ 已成功优化 6 处任务关系约束违反
建议重新运行冲突分析验证结果
```

---

## 3. 完整工作流程建议

### 3.1 初次排课后的质量评估

```bash
# Step 1: 运行排课
python suan2.py --version 1 --population 200 --generations 150

# Step 2: 分析未满足的约束
python show_unsatisfied_constraints.py 1

# Step 3: 查看Excel报告，评估问题严重程度
# 文件: 未满足约束详细报告_版本1_YYYYMMDD_HHMMSS.xlsx
```

### 3.2 优化排课结果

```bash
# Step 4: 运行冲突优化工具
python analyze_conflicts.py 1

# 按照提示逐步优化:
# - 优化容量冲突 (y)
# - 优化时间冲突 (y)
# - 优化教室利用率 (y)
# - 优化教师偏好 (y)
# - 优化任务关系约束 (y) ⭐ 新增
```

### 3.3 验证优化效果

```bash
# Step 5: 重新分析约束满足情况
python show_unsatisfied_constraints.py 1

# Step 6: 比较优化前后的Excel报告
# 检查改进效果
```

### 3.4 迭代优化（如需要）

如果还有未满足的约束:

```bash
# Option A: 调整遗传算法参数重新排课
python suan2.py --version 2 --population 300 --generations 200

# Option B: 手动调整特定课程
# 在数据库中直接修改 schedules 表

# Option C: 调整约束配置
# 修改 task_relation_constraints 表的 penalty_score
# 修改 teacher_preferences 表的 penalty_score
```

---

## 4. 可优化性标记说明

两个工具都会标记约束是否可优化:

| 约束类型         | 可优化        | 优化方式                    |
| ---------------- | ------------- | --------------------------- |
| 教师偏好时间     | ✅            | 调整课程时间到偏好时段      |
| 教师避免时间     | ✅            | 调整课程时间避开避免时段    |
| 教室利用率低     | ✅            | 更换为更小的教室            |
| 教室利用率高     | ✅            | 更换为更大的教室            |
| 学生负荷过重     | ⚠️ 部分可优化 | 调整课程到其他天            |
| **任务关系约束** | ✅            | **调整任务时间满足关系** ⭐ |
| 课程时段偏好     | ⚠️ 部分可优化 | 调整必修课到白天            |
| 教室连续性       | ⚠️ 部分可优化 | 固定教室                    |
| 跨校区通勤       | ⚠️ 部分可优化 | 调整时间避免冲突            |

**图例**:

- ✅ **完全可优化**: `analyze_conflicts.py` 提供自动优化功能
- ⚠️ **部分可优化**: 需要手动调整或重新排课
- ❌ **不可优化**: 硬约束冲突，必须重新排课

---

## 5. 任务关系约束详细说明

### 5.1 约束类型

#### REQUIRE_SAME_DAY (要求同一天)

- **用途**: 要求一门课程的两次上课必须在同一天
- **适用场景**:
  - 需要连续上课的理论+实验课
  - 上下午连续的课程
- **优化策略**: 将其中一次课调整到另一次课的同一天

#### AVOID_CONSECUTIVE_DAYS (避免连续天)

- **用途**: 要求一门课程的两次上课不能在连续的两天
- **适用场景**:
  - 需要消化时间的课程
  - 避免学生连续高强度学习
- **优化策略**: 将课程调整到非连续天（至少间隔 1 天）

#### MIN_DAYS_APART (最小间隔天数)

- **用途**: 要求一门课程的两次上课至少间隔 N 天
- **适用场景**:
  - 需要充分准备的课程
  - 作业/实验需要时间完成
- **优化策略**: 调整课程使间隔 ≥N 天

### 5.2 优化示例

**场景**: 高等数学 I 每周上 2 次课

**约束设置**:

```sql
INSERT INTO task_relation_constraints
(offering_id, task_sequence_a, task_sequence_b, constraint_type, penalty_score)
VALUES
(101, 1, 2, 'AVOID_CONSECUTIVE_DAYS', 200);
```

**当前排课** (违反约束):

- 第 1 次: 周一 第 3 节
- 第 2 次: 周二 第 9 节
- ❌ 连续两天上课

**优化后**:

- 第 1 次: 周一 第 3 节
- 第 2 次: 周三 第 9 节
- ✅ 间隔 1 天，满足约束

---

## 6. 常见问题

### Q1: 为什么有些约束无法优化?

**A**: 可能原因:

1. **硬约束冲突**: 所有可用时间都有教师/班级/教室冲突
2. **资源不足**: 没有合适的教室或时间槽
3. **约束冲突**: 多个约束互相矛盾

**解决方案**:

- 增加教室资源
- 放宽部分约束
- 调整课程节数
- 重新运行遗传算法

### Q2: 优化后为什么还有违反?

**A**: 优化是增量式的，可能需要多次迭代:

1. 运行一次优化
2. 重新分析约束
3. 再次优化
4. 重复直到满意

### Q3: 如何设置合理的惩罚分数?

**A**: 建议权重:

- **硬约束**: 不应违反（由系统自动保证）
- **重要软约束**: 200-500 分（如任务关系、教师避免时间）
- **一般软约束**: 50-150 分（如教室利用率、连续性）
- **弱软约束**: 10-40 分（如时段偏好）

### Q4: Excel 报告如何使用?

**A**: Excel 报告包含多个工作表:

1. **教师偏好违反**: 按惩罚分数排序，优先优化
2. **教室利用率**: 按浪费座位数排序，批量调整
3. **学生负荷**: 按总节数排序，重点关注>12 节的
4. **任务关系违反** ⭐: 按惩罚分数排序，可直接优化
5. **时段问题**: 按课程性质筛选，调整必修课

---

## 7. 技术细节

### 7.1 数据库表关系

涉及的主要表:

- `task_relation_constraints`: 任务关系约束配置
- `teacher_preferences`: 教师偏好配置
- `schedules`: 排课结果
- `teaching_tasks`: 教学任务
- `classrooms`: 教室信息

### 7.2 优化算法

**任务关系约束优化算法**:

1. 查询所有违反的约束
2. 根据约束类型确定目标时间
   - `REQUIRE_SAME_DAY`: 目标星期 = 另一任务的星期
   - `AVOID_CONSECUTIVE_DAYS`: 目标星期 = 非连续天
   - `MIN_DAYS_APART`: 目标星期 = 当前星期 ± N 天
3. 在目标星期查找可用时间槽（检查硬约束）
4. 生成调整方案
5. 用户确认后应用到数据库

### 7.3 周次处理

优化时会考虑周次重叠:

- 优先使用 `offering_weeks` 表的精确周次
- 如无数据，根据 `week_pattern` 生成周次集合
- 只有周次有重叠才检测冲突

---

## 8. 总结

### 核心优势

1. **全面性**: 覆盖 7 个维度的软约束分析
2. **可视化**: Excel 报告便于查看和导出
3. **可操作**: 明确标注哪些可以优化
4. **智能化**: 自动寻找最优调整方案
5. **安全性**: 优化时保证不违反硬约束
6. **灵活性**: 用户可选择性应用优化

### **新增亮点** ⭐

- **任务关系约束分析**: 完整支持 3 种约束类型
- **任务关系约束优化**: 自动调整任务时间满足约束
- **交互式优化**: 逐步引导，用户可控
- **优化效果验证**: 优化后重新分析验证

### 最佳实践

1. 每次排课后先运行 `show_unsatisfied_constraints.py`
2. 查看 Excel 报告，评估问题分布
3. 使用 `analyze_conflicts.py` 逐步优化
4. 重新分析验证效果
5. 必要时调整约束配置或重新排课

---

## 附录: 命令速查

```bash
# 1. 生成排课
python suan2.py --version 1 --population 200 --generations 150

# 2. 分析约束
python show_unsatisfied_constraints.py 1

# 3. 优化排课
python analyze_conflicts.py 1

# 4. 查看版本信息
python -c "import pymysql, os; conn = pymysql.connect(host=os.getenv('DB_HOST') or 'localhost', port=3306, user=os.getenv('DB_USER') or 'pk', password=os.getenv('DB_PASSWORD') or '123456', database=os.getenv('DB_NAME') or 'paike'); cursor = conn.cursor(); cursor.execute('SELECT version_id, version_name, semester, status FROM schedule_versions'); print('\n'.join([f'{r[0]}: {r[1]} ({r[2]}) - {r[3]}' for r in cursor.fetchall()])); conn.close()"
```

---

**文档版本**: v1.0  
**更新日期**: 2025-12-04  
**作者**: 排课系统开发团队
