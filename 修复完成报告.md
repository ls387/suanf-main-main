# 周次支持修复完成报告

**修复日期**: 2025-11-25  
**修复状态**: ✅ 已完成所有 P0 级问题

---

## 修复内容总结

### 🔴 P0 - 已修复的紧急问题

#### 1. ✅ 修复班级冲突检测 (`genetic_algorithm.py`)

**问题**: 班级冲突检测只检查时间，不检查周次是否重叠

**修复内容**:

- 在 `_has_time_conflict` 方法中添加 `class_schedule_with_weeks` 参数
- 班级冲突检测逻辑修改为检查周次重叠：
  ```python
  if class_schedule_with_weeks and weeks:
      for class_id in class_ids:
          for time_key in time_slots:
              if time_key in class_schedule_with_weeks[class_id]:
                  for other_weeks in class_schedule_with_weeks[class_id][time_key]:
                      if len(weeks & other_weeks) > 0:
                          return True  # 时间冲突且周次重叠才算冲突
  ```

**影响**: 同一班级的单周和双周课程现在可以安排在同一时间而不会被误判为冲突

---

#### 2. ✅ 修复冲突优化算法 (`analyze_conflicts.py`)

**问题**: 冲突优化的 `occupied_times` 只记录时间，不记录周次，可能产生新冲突

**修复内容**:

- 重构 `occupied_times` 数据结构：

  ```python
  # 旧结构: occupied_times[type][id] = Set[(weekday, slot)]
  # 新结构: occupied_times[type][id][(weekday, slot)] = [weeks1, weeks2, ...]
  occupied_times = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
  ```

- 修改 `check_time_available` 函数添加周次参数：

  ```python
  def check_time_available(..., weeks=None):
      if time_key in occupied_times["classroom"][classroom_id]:
          if weeks:
              for occupied_weeks in occupied_times["classroom"][classroom_id][time_key]:
                  if len(weeks & occupied_weeks) > 0:  # 检查周次重叠
                      return False
  ```

- 更新 `find_alternative_time_for_preference` 函数：
  - 添加 `get_weeks_func` 参数
  - 调用 `check_time_available` 时传入周次信息

**影响**: 优化算法现在能正确识别单双周课程可共享时间，不会产生误报冲突

---

#### 3. ✅ 修复教室冲突检测 (`genetic_algorithm.py`)

**问题**: 教室选择只检查时间占用，不检查周次，浪费教室资源

**修复内容**:

- 在 `_select_classroom` 方法中添加 `classroom_schedule_with_weeks` 参数
- 教室时间冲突检测修改为考虑周次重叠：
  ```python
  if classroom_schedule_with_weeks and task.weeks:
      for time_key in time_slots:
          if time_key in classroom_schedule_with_weeks[classroom.classroom_id]:
              for other_weeks in classroom_schedule_with_weeks[classroom.classroom_id][time_key]:
                  if len(task.weeks & other_weeks) > 0:
                      has_conflict = True  # 周次重叠才算冲突
  ```

**影响**: 单周和双周课程现在可以共享同一教室的同一时间段，提高教室利用率

---

### 数据结构修改

#### `create_individual` 方法

添加带周次信息的数据结构构建：

```python
# 跟踪带周次信息的占用情况
class_schedule_with_weeks = defaultdict(lambda: defaultdict(list))
classroom_schedule_with_weeks = defaultdict(lambda: defaultdict(list))
```

#### `_update_schedules` 方法

同时维护两种数据结构：

```python
def _update_schedules(..., class_schedule_with_weeks=None, classroom_schedule_with_weeks=None):
    # 更新简单schedule
    class_schedule[class_id].update(time_slots)

    # 更新带周次的schedule
    if class_schedule_with_weeks and task.weeks:
        for time_key in time_slots:
            class_schedule_with_weeks[class_id][time_key].append(task.weeks)
```

#### `optimize_preferences` 函数

添加 `get_weeks` 函数定义，用于从结果中提取周次信息。

---

## 测试验证

创建了 `test_week_fixes.py` 测试脚本，包含以下测试：

1. **班级冲突检测测试**: 验证同一班级的单双周课程在同一时间不会误报冲突
2. **教室冲突检测测试**: 验证同一教室的单双周课程可以共享时间
3. **周次重叠检测测试**: 验证周次有重叠时正确检测冲突
4. **实际数据验证**: 加载数据库验证单双周课程正确识别

运行测试：

```bash
python test_week_fixes.py
```

---

## 影响评估

### ✅ 解决的问题

1. **消除误报冲突**: 同一班级的单双周课程不再被误判为冲突
2. **提高教室利用率**: 单双周课程可以共享教室，节省教室资源
3. **优化算法正确性**: 冲突优化不会产生新的周次冲突

### 📊 预期效果

- **冲突数量减少**: 之前误报的单双周冲突将消失
- **教室利用率提升**: 估计可提升 10-20%（取决于单双周课程比例）
- **排课成功率提高**: 更多课程能找到合适的时间和教室

---

## 后续建议

### 1. 重新排课 ⚠️ 重要

当前数据库中的排课版本 1 是基于**错误的周次数据**生成的，建议：

```bash
# 删除旧版本
python suan2.py --delete-version 1

# 生成新版本
python suan2.py
```

### 2. 验证新结果

```bash
# 查看新结果
python view_schedule.py 2

# 分析冲突
python analyze_conflicts.py 2
```

### 3. 对比分析

比较新旧版本的：

- 冲突数量（预期：显著减少）
- 教室利用率（预期：提升）
- 单双周课程的时间安排（预期：可共享时间）

### 4. 清理测试文件

修复验证完成后可以删除：

- `test_week_fixes.py`
- `test_weeks.py`
- 其他临时测试文件

---

## 技术细节

### 修改的文件

1. `genetic_algorithm.py` - 遗传算法核心（467 行修改）
2. `analyze_conflicts.py` - 冲突分析和优化（153 行修改）

### 修改的函数

- `genetic_algorithm.py`:

  - `create_individual()` - 添加带周次的数据结构
  - `_create_gene_for_task()` - 传递周次参数
  - `_has_time_conflict()` - 添加班级周次检测
  - `_select_classroom()` - 添加教室周次检测
  - `_update_schedules()` - 维护带周次的 schedule
  - `fitness()` - 构建带周次的数据结构

- `analyze_conflicts.py`:
  - `optimize_preferences()` - 添加 get_weeks 函数定义
  - `check_time_available()` - 添加周次参数和检测逻辑
  - `find_alternative_time_for_preference()` - 传递周次信息
  - 构建 occupied_times 时包含周次信息

### 数据结构变化

**旧结构** (问题版本):

```python
class_schedule[class_id] = Set[(weekday, slot), ...]
occupied_times["classroom"][id] = Set[(weekday, slot), ...]
```

**新结构** (修复版本):

```python
# 简单结构（向后兼容）
class_schedule[class_id] = Set[(weekday, slot), ...]

# 带周次结构（新增）
class_schedule_with_weeks[class_id][(weekday, slot)] = [weeks1, weeks2, ...]
occupied_times["classroom"][id][(weekday, slot)] = [weeks1, weeks2, ...]
```

---

## 总结

✅ **所有 P0 级问题已修复**
✅ **向后兼容性保持**（无周次信息时使用保守策略）
✅ **测试脚本已创建**
⚠️ **需要重新排课生成新版本验证效果**

修复后，系统现在能够：

1. 正确区分单周、双周和全学期课程
2. 允许单双周课程共享时间和教室
3. 在冲突优化时保持周次正确性
4. 避免误报不存在的冲突

**下一步**: 运行 `python suan2.py` 重新排课，然后用 `analyze_conflicts.py` 验证新结果。
